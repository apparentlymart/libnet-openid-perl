<?page
wintitle=>Specs
body<=

<h2>Warning</h2>
This spec was the original working prototype, but it's being changed a bit to address community feedback.  Don't implement anything based off this.

<h2>How OpenID works</h2>

<ul class='spaced'>
<li>You maintain a blog at, say, livejournal.com (but this can be anything) and you stay logged in there all the time.</li>

<li>You go to leave a comment at someblog.com (perhaps it's Movable Type, or Wordpress, or DeadJournal, ...) and you don't have an account there, so there's otherwise no way to leave an authenticated comment.  But if their blog-system has OpenID support, you see something like:  (but hopefully prettier)
<div style='margin: 1em 0 1em 2em; border-left: 2px solid black; padding-left: 1em;'>
<form>
<b>Login with your blog URL:</b> <input class='sexy' size='30' value="" /> <input type='button' value='Login' /><br />
<i>For example: <tt>happygirl.bloghost.com</tt></i>
</form>
</div>
</li>

<li>It'd be a spec recommendation that the "http://" prefix is implied if left off, so one could just enter "bob.livejournal.com" as their identifier.</li>

<li>It's also recommend that the form field be named <b>openid_url</b> so browsers auto-complete user's URLs between different sites, in the same way the ecommerce world tends to use conventions like "address1" and "address2".</li>

<li>In the AJAX version, pressing Login does an XMLHttpRequest/IFRAME post to the server (someblog.com) and says, "Hey, resolve this URL."  The server, with appropriate care, fetches the user's identity URL.  If it's HTML, it finds the OpenID &lt;link&gt; auto-discovery tag, which looks like:<div style='margin: 1em 0 1em 2em; border-left: 2px solid black; padding-left: 1em'><b>&lt;link rel="openid.server" href="http://www.livejournal.com/auth/?type=openid" /&gt;</b></div>The href is the endpoint for all communication about that user's identity.  Respect existing URL arguments in there.... they can't be chopped off.  If the identity consumer had to follow redirects until it got to a page with the link tag, the final URL is the identity URL which will be asserted, not what the user typed in.  Also, if the user entered a bare hostname ("bradfitz.com") with no path, the implied path that you must verify is "/", along with the "http://" prefix.   So "bradfitz.com" would map to "http://bradfitz.com/" (unless fetching that led to redirects, as previously covered)</li>

<li>The helper process on the identity consumer's then returns to the client's browser the:

<ul>
<li>the user's canonicalized identity URL (see previous bullet for canonicalization rules)</li>
<li>the user's identity server URL (again, perhaps a separate host from the HTML servers)</li>
</ul>

<li>The client's browser then opens a hidden IFRAME to the ID server, setting the following URL arguments:  (<em style='color:red'>Note:</em>  It's critical that you preserve existing URL arguments that you found.  Don't just concatenate a "?" and these args.  It is safe to destroy existing args of these same names, though, since identity servers should never use arguments beginning with "openid." for their own purposes.)
    <ul>
        <li><b>openid.mode</b> -- Either <tt class='spec'>checkid_immediate</tt> or <tt class='spec'>checkid_setup</tt>.  The immediate mode means the identity server is to redirect immediately with either a positive signed assertion, or a negative assertion in the form a user_setup_url where the user should go before the assertion can be made.  The checkid_setup mode is used in the non-AJAX mode, and indicates to the identity server that it's allowed to take control of the user agent and give them a real page, redirect them its own server, etc., in order to log them in, setup trust, and do whatever's necessary for the assertion to be made.  In setup mode, the final step is the identity server returning the user to the return_to URL, covered below.</li>

        <li><b>openid.return_to</b> -- The URL the ID server will redirect the user to.  May contain a query string.  The identity server must preserve it.</li>
        <li><b>openid.trust_root</b> <i>(Optional, but recommended)</i> -- The URL which the user will actually see to approve.  The return_to URL must descend from the trust_root, or the identity server will return an error, not a redirect.  Namely, the URL scheme and port must match.  The path, if present, but be equal or below the trust_root, and the domains on both must match, or, the trust_root contain a wildcard like <tt>http://*.livejournal.com</tt> (but the wildcard may only be at the beginning)  You can try to pass things like http://*.com/ or http://*.co.uk/, but any respectable identity server will protect their users from that.  Defaults to return_to URL if absent.</li>
        <li><b>openid.is_identity</b> -- The identity URL the client is asking the ID server to verify.  The exact question is:  "Does the user logged in to your site own this URL, <i>and</i> do they allow the trust_root (and therefore the return_to URL) to know that?"  (Note that the question isn't "Who's logged in?")  <em style='color:red'>Note:</em> An identity server should only assert to URLs that it manages/produces directly.  If your identity server will let users specify their own URLs to assert to, you shouldn't do that unless their identity server URL specified in that offsite URLs contains an extra parameter saying what username they are on the identity server.   (TODO: seperate page and graphic for the <i>"Ambiguous Loop Problem"</i>)</li>
    </ul>
</li>

<li>The server then replies with an HTTP redirect to the specified return_to URL, with the following GET arguments appended (preserving the existing query string if present in the return_to URL)
    <ul>
       <li><b>openid.mode</b> = <tt class='spec'>id_res</tt></li>
       <li><i>(Conditional)</i>  <b>openid.user_setup_url</b> = [url]  If the identity assertion fails, the server provides this URL for where the user can do whatever's necessary to fulfill the assertion, be it login, setup permissions, etc.  The server should return a URL which doesn't imply anything about what's needed, so the client is left in the dark about why the assertion failed.

<br /><br />The identity consumer site can augument this URL with the following option before sending the user-agent to the user_setup_url: (preserving existing query parameters):
             <ul>
               <li><b>openid.post_grant</b> <i>(Optional)</i> -- Requested behavior the identity server should take after the user has granted permission to trust_root.  If unspecified, behavior is undefined.  Accepted values are <tt class='spec'>close</tt> (to close the browser window, if it was opened with javascript window.open or a _blank target window), or <tt class='spec'>return</tt>, to return to the original return_to URL.  In the case </li>
             </ul>
       </li>

	<li>If, however, these three conditions apply:
             <ol>
               <li>Some user is logged in</li>
               <li>That user controls the URL asked about in the <tt>openid.is_identity</tt> request arg.</li>
               <li>That user has told the ID server (say, LiveJournal) that they trust the <tt>openid.trust_root</tt> URL with their identity.</li>
             </ol>
           Then you get back the following arguments:
             <ul>
               <li><b>openid.assert_identity</b> with the value that you sent in in the openid.is_identity request.</li>
               <li><b>openid.return_to</b> with the value that you originall requested in openid.return_to.  This will be equal to the current URL, less the extra arguments that the response adds.</li>
               <li><b>openid.timestamp</b>, the timestamp in w3c format.  It must be in the UTC timezone, indicated with a "Z", like:  "2005-05-15T17:11:51Z".  The consumer may use this to determine if the signature is valid within some window.</li>
	       <li><b>openid.sig</b>, the DSA signature of form BASE64(DSA(SHA1("[timestamp]::assert_identity::[assert_identity]::[return_to]"))) where the DSA function returns a DER encoding of the ASN1 schema SEQUENCE(INTEGER,INTEGER) where the two integers are "r" and "s" from DSA.  And of course, the entire thing is URL-escaped.</li>
              </ul>
       </li>
    </ul>
</li>


<li>The IFRAME that was previously loading from another domain is now loading from the same domain, so the return_to URL generates an HTML page with JavaScript that verifies its window location hostname is the same as its parent's location hostname (or else a JavaScript security exception is thrown) and then proceeds to pass the answer up to the parent window's closure which the OpenID library already registered, propogating back the assertion and DSA signature, or the user setup URL.</li>

<li>User submits their comment/etc and the someblog.com server, along with the identity URL, DSA signature, and assertion timestamp, and the server can then verify the signature using either its cached version of the ID server's public key, or get it directly from the ID server URL adding the GET argument <b>openid.mode</b> of value <tt class='spec'>getpubkey</tt> which returns the DSA public key in PEM format.  <em style='color:red'>Note:</em>  on POST submission, the server should verify (likely from cache) the value of the identity URL's identity server, and not just blindly trust an identity server URL that your app might naively pass back to itself.</li>

<li>In the end, what was accomplished is:  <b>A OpenID-enabled site can ensure that for a given identity URL, only the person owning that URL can authenticate, and nobody else can fake that identity.</b>  Additionally, this prevents the ability for a malicious site author to extract a person's identity without their effort and consent.  (entering their URL, then telling their ID server they trust them)</li>

</ul>

<h2>Misc Notes</h2>

Limits on URL lengths:
<ul>
<li>Identity URL: <b>255 max bytes</b>
<li>Identity server URL: <b>2047 max bytes</b> (after consumer-added URL arguments, so keep the raw endpoint URL well below this)
<li>return_to URL: <b>2047 max bytes</b> (after identity-server added URL arguments, so keep the raw return_to URL well below this)
<li>assoc_handle: <b>255 characters or less</b>, and consist only of ASCII characters in the range 33-126 inclusive (ie printable non-whitespace characters).</li>

</ul>


<=body
page?>
